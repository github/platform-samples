require 'sinatra'
require 'json'
require 'openssl'
require 'octokit'
require 'jwt'
require 'httparty'
require 'time' # This is necessary to get the ISO 8601 representation of a Time object

#
#
# What does this app do? Let's build a basic CI server.
# This server will watch for pull requests on the repositories it's installed on
# When a new PR is opened, we get a `check_suite` event. We use that as a signal to start a run!
# We tell GitHub that we are starting a run, and that it is "in progress".
# Then we don't actually do anything! THis is just demo code, after all.
# Instead, we wait for GitHub to acknowledge the creation of a new check run with a `check_run` event.
# When we get that, we'll update the state of the check from "in progress" to "complete: success!"
# And that's it!
#
#

class CIAppTutorial < Sinatra::Base

# Never, ever, hardcode app tokens or other secrets in your code!
# Always extract from a runtime source, like an environment variable.
#
# Notice that the private key must be in PEM format, but the newlines should be stripped and replaced with the literal `\n`
  PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n")) # convert newlines
# You set the webhook secret when you create your app. This verifies that the webhook is really coming from GH
  WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']
# Get the app identifier—an integer—from your app page after you create your app.
  APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

# Before each request, instantiate an Octokit client using a JWT that we generate with our private key
  before do
    payload = {
        # issued at time
        iat: Time.now.to_i,
        # JWT expiration time (10 minute maximum)
        exp: Time.now.to_i + (10 * 60),
        # The GitHub App's identifier
        iss: APP_IDENTIFIER
    }
    JWT.encode(payload, PRIVATE_KEY, 'RS256')
    @client ||= Octokit::Client.new(bearer_token: get_jwt)
  end

# This is the webhook endpoint that GH will call with events.
  post '/event_handler' do
    request.body.rewind
    payload_raw = request.body.read
    payload = JSON.parse payload_raw

    # Check X-Hub-Signature to confirm that this webhook was generated by GH
    # The signature comes in with header x-hub-signature, and looks like "sha1=123456"
    # We should take the left hand side as the signature method, and the right hand side as the HMAC itself
    method, their_digest = request.env['HTTP_X_HUB_SIGNATURE'].split('=')
    our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, payload_raw)
    if their_digest != our_digest
      return 401
    end

    # Determine what kind of event this is, and take action as appropriate
    puts "---- recevied event #{request.env['HTTP_X_GITHUB_EVENT']}"
    puts "----         action #{payload['action']}"

    case request.env['HTTP_X_GITHUB_EVENT']
    when 'check_suite'
      # A new check_suite has been created or rerequested. Create a new check_run with status "running"
      if payload['action'] == 'requested' || payload['action'] == 'rerequested'
        create_check_run(payload)
      end

    when 'check_run'
      # GH confirms our new check_run has been created, or rerequested. Update it to "completed"
      if payload['action'] == 'created' || payload['action'] == 'rerequested'
        update_check_run(payload)
      end
    end

    "ok"
  end


########## Helpers

  helpers do
    def create_check_run(payload)
      # First, we need to exchange our JWT for an installation token against the repository that triggered this check suite
      token = get_installation_token(payload)
      installation_client = Octokit::Client.new(bearer_token: token)

      # Octokit doesn't yet support the Checks API, but it does provide generic HTTP methods we can use!
      # https://developer.github.com/v3/checks/runs/#create-a-check-run
      result = installation_client.post("#{payload['repository']['url']}/check-runs", {
          accept: 'application/vnd.github.antiope-preview+json', # This header is necessary for beta access to Checks API
          name: 'Awesome CI',
          head_branch: payload['check_suite']['head_branch'],
          head_sha: payload['check_suite']['head_sha'],
          status: :in_progress
      })

      # Assuming that this notifcation goes through, we can start our actual build run here.
      # To simulate this, we'll wait for GitHub to acknowldge the creation of the run, and update its status to
      # "success" from there.

      result.attrs
    end

    def update_check_run(payload)
      token = get_installation_token(payload)
      installation_client = Octokit::Client.new(bearer_token: token)
      # Update the check run to a success state. We could include other information like line numbers, comments,
      # or other things to help in the case of failure
      # Also, normally, we would make this call when we were actually done with our CI, not as an artificial
      # side effect of a check run being initiated.

      # Octokit doesn't yet support the Checks API, but it does provide generic HTTP methods we can use!
      # https://developer.github.com/v3/checks/runs/#update-a-check-run
      # notice the verb! PATCH!
      result = installation_client.patch(payload['check_run']['url'], {
          accept: 'application/vnd.github.antiope-preview+json', # This header is necessary for beta access to Checks API
          name: 'Awesome CI',
          status: :completed,
          conclusion: :success,
          completed_at: Time.now.utc.iso8601
      })

      result.attrs
    end

    def get_installation_token(payload)
      # We include the accept header because GH Apps are still in beta, and this header requests access to that beta
      @client.create_app_installation_access_token(payload['installation']['id'],
                                                   accept: 'application/vnd.github.machine-man-preview+json')['token']

      # TODO no error checking being done here.
    end
  end
end
